Binary Search

总结：

二分查找针对的是一个有序的数据集合，查找的思想有点类似于分治思想，每次通过跟区间的中间元素对比，将待查询的区间缩小为之前的一半，知道找到要查找的元素，或者区间被缩小
为0

二分查询的时间复杂度：

n,n/2,n/4,n/8,...2的k次方/n

这是一个等比数列 n/2的k次方=1 k=log2n 时间复杂度就是O(logn)，最坏的情况也就是当查找的区间被缩小为空，才停止。

O(logn)这个时间复杂度可能比O(1)执行的时间还要快。


指数时间复杂度在大规模的数据面前是不怕的。


二分查找的代码实现：

1、情况一：有序数组中不存在不重复的元素；


容易出错的地方：

1、注意是low<=high,而不是low<high,因为可能有两个指针相等的情况。

2、mid的取值，mid=(low+high)/2是有问题的，因为当low和high比较大的时候，两者的和就可能会溢出，改进为low+(high-low)/2

   **：因为在low和high都很大的时候，两数相加可能会存在溢出的可能，变成一个负数
   
      一个简单的数学公式
      mid=(low+high)/2=(low+low+high-low)/2=low+(high-low)/2
      
      位运算：
      low+(（high-low）>>1) 除以2这个操作可以使用位运算。
      
3、low和high的更新。
    每次和中位数进行大小的比较，low=mid+1，high=mid-1 这里注意不要写成low=mid或者high=mid，容易发生死循环。
    
    
    用递归的方式编写二分查找
    
   
   二分查找应用场景的局限性：
   
   1、首先二分依赖的是顺序表结构，简单的说就是数组
   
   那我们思考，链表可不可以进行二分查找，答案是不行的，主要原因是二分查找算法需要根据下标随机访问元素，但是链表随机访问的时间复杂度是O(n)，那么效率也太差了
   
   2、二分查找针对的是有序的数据。
   
   对于静态的数据，进行二分查询很高效，但是对于多次插入和删除，要在每次二分查找的时候进行排序，维护的成本还是很高的；
   
   3、数据量太小不适合二分查找
   
    如果数据之间的比较操作非常耗时，不管数据量大小，都推荐使用二分查找
    
    
    数据量太大的情况下也不适合二分查询
    
    因为二分的底层其实是数组这种数据结构，对内存的要求是比较高的。
    
    
    问题：如何在1000万个整数中快速的寻找某个整数
    
    二分查找
    
    总结：
    
    1、底层必须依赖数组
    2、要求数据必须是有序的
    3、编写二分代码的几个容易错的地方。
    
    
    
    
   
   
   
   
    
    
      
      


